% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgcca_permutation.R
\name{rgcca_permutation}
\alias{rgcca_permutation}
\title{Tune the S/RGCCA hyper-parameters by permutation}
\usage{
rgcca_permutation(
  blocks,
  par_type,
  par_value = NULL,
  par_length = 10,
  n_perms = 20,
  n_cores = parallel::detectCores() - 1,
  quiet = TRUE,
  scale = TRUE,
  scale_block = TRUE,
  method = NULL,
  connection = 1 - diag(length(blocks)),
  scheme = "factorial",
  ncomp = rep(1, length(blocks)),
  tau = rep(1, length(blocks)),
  sparsity = rep(1, length(blocks)),
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  response = NULL,
  superblock = FALSE,
  NA_method = "nipals",
  rgcca_res = NULL,
  verbose = TRUE
)
}
\arguments{
\item{blocks}{A list that contains the J blocks of variables
\eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}{X1, X2, ..., XJ}.
Block \eqn{\mathbf{X}_j}{Xj} is a matrix of dimension
\eqn{n \times p_j}{n x p_j} where n is the number of
observations and \eqn{p_j} the number of variables.}

\item{par_type}{A character string indicating the parameters to tune between
"sparsity" and "tau".}

\item{par_value}{Sets of penalties to consider during the permutation
process.
If par_value = NULL, it takes 10 sets between min values (0 for RGCCA and
1/sqrt(ncol(Xj)) for SGCCA) and 1. Otherwise, it could be either (i) A matrix
of dimension IxJ (where I the number of combinations to be tested and J the
number of blocks), or (ii) a vector of length J length specifying the maximal
values to consider for each block. In that case, par_length combinations
are tested from min values to the maximal values specified by this vector.
(iii) a numerical value giving the same maximal value to be considered for
each block. In that case par_length combinations are tested from min values
to this single maximal value.}

\item{par_length}{A numeric value indicating the number of sets of penalties
to be tested (if par_value = NULL).}

\item{n_perms}{Number of permutations for each set of constraints (default
is 20).}

\item{n_cores}{Number of cores for parallelization.}

\item{quiet}{Logical value indicating if warning messages are reported.}

\item{scale}{Logical value indicating if blocks are standardized.}

\item{scale_block}{Value indicating if each block is divided by
a constant value. If TRUE or "inertia", each block is divided by the
sum of eigenvalues of its empirical covariance matrix.
If "lambda1", each block is divided by the square root of the highest
eigenvalue of its empirical covariance matrix.
Otherwise the blocks are not scaled. If standardization is
applied (scale = TRUE), the block scaling is applied on the result of the
standardization.}

\item{method}{A character string indicating the multi-block component
method to consider: rgcca, sgcca, pca, spca, pls, spls, cca,
ifa, ra, gcca, maxvar, maxvar-b, maxvar-a, mcoa,cpca-1, cpca-2,
cpca-4, hpca, maxbet-b, maxbet, maxdiff-b, maxdiff, maxvar-a,
sabscor, ssqcor, ssqcor, ssqcov-1, ssqcov-2, ssqcov, sumcor,
sumcov-1, sumcov-2, sumcov, sabscov, sabscov-1, sabscov-2.}

\item{connection}{A symmetric matrix (\eqn{J \times J}{J x J}) that
describes the relationships between blocks.}

\item{scheme}{Character string or a function giving the scheme function for
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). The scheme function
 can be any continously differentiable convex function and it is possible to
 design explicitely the sheme function (e.g. function(x) x^4) as argument of
 rgcca function.  See (Tenenhaus et al, 2017) for details.}

\item{ncomp}{Vector of length J indicating the number of block components
for each block.}

\item{tau}{Either a \eqn{1 \times J}{1 x J} vector or a
\eqn{\mathrm{max}(ncomp) \times J}{max(ncomp) x J} matrix containing
the values of the regularization parameters (default: tau = 1, for each
block and each dimension). The regularization parameters varies from 0
(maximizing the correlation) to 1 (maximizing the covariance). If
tau = "optimal" the regularization parameters are estimated for each block
and each dimension using the Schafer and Strimmer (2005) analytical formula.
If tau is a \eqn{1 \times J}{1 x J} vector, tau[j] is identical across the
dimensions of block \eqn{\mathbf{X}_j}{Xj}. If tau is a matrix, tau[k, j]
is associated with \eqn{\mathbf{X}_{jk}}{Xjk} (kth residual matrix for
block j). The regularization parameters can also be estimated using
\link{rgcca_permutation} or \link{rgcca_cv}.}

\item{sparsity}{Either a \eqn{1*J} vector or a \eqn{max(ncomp) * J} matrix
encoding the L1 constraints applied to the outer weight vectors. The amount
of sparsity varies between \eqn{1/sqrt(p_j)} and 1 (larger values of sparsity
correspond to less penalization). If sparsity is a vector, L1-penalties are
the same for all the weights corresponding to the same block but different
components:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.
If sparsity is a matrix, each row \eqn{h} defines the constraints applied to
the weights corresponding to components \eqn{h}:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[h,j] \sqrt{p_j}.} It can be
estimated by using \link{rgcca_permutation}.}

\item{init}{Character string giving the type of initialization to use in
the  algorithm. It could be either by Singular Value Decompostion ("svd")
or by random initialisation ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for the convergence of the algorithm.}

\item{response}{Position of the response block}

\item{superblock}{Boolean indicating the presence of the superblock.
Default = TRUE}

\item{NA_method}{Character string corresponding to the method used for
handling missing values ("nipals", "complete"). (default: "nipals").
\itemize{
\item{\code{"complete"}}{corresponds to perform RGCCA on the fully observed
observations (observations with missing values are removed)}
\item{\code{"nipals"}}{corresponds to perform RGCCA algorithm on available
data (NIPALS-type algorithm)}}}

\item{rgcca_res}{A fitted RGCCA object (see  \code{\link[RGCCA]{rgcca}})}

\item{verbose}{Logical value indicating if the progress of the
permutation procedure is reported.}
}
\value{
\item{zstat}{A vector of Z-statistics, one zstat per set of tuning
parameters.}

\item{bestpenalties}{The set of tuning parameters that yields the
highest Z-statistics}

\item{permcrit}{Matrix of permuted S/RGCCA criteria. The ith row of
permcrit contains the n_perms values of S/RGCCA permuted criteria
obtained for each set of tuning parameters.}

\item{means}{A vector that contains, for each set of tuning
parameters, the mean of the permuted R/SGCCA criteria}

\item{sds}{A vector that contains, for each set of tuning
parameters, the standard deviation of the permuted R/SGCCA criteria}

\item{crit}{A vector that contains, for each set of tuning
parameters, the value of the R/SGCCA criteria obtained from the original
data.}

\item{pval}{Vector of p-values, one per set of tuning parameters.}

\item{penalties}{Matrix giving, the set of tuning paramaters
considered during the permutation process (tau or sparsity).}
}
\description{
This function can be used to automatically select the hyper-parameters
(amount of sparsity for sgcca or shrinkage parameters for RGCCA).
A permutation based strategy very similar to the one proposed in
(Witten et al, 2009) is implemented.
}
\details{
The tuning parameters are selected using the permutation scheme proposed in
(Witten et al, 2009). For each candidate tuning parameter value, the
following is performed:

(1) Repeat the following n_perms times (for n_perms large): \cr
   \verb{    }(a) The samples in \eqn{X_1},..., \eqn{X_J} are randomly
   permuted blocks: \eqn{X_1^*},..., \eqn{X_J^*}. \cr
   \verb{    }(b) S/RGCCA is run on the permuted data sets \eqn{X_1^*},...,
      \eqn{X_J^*} to get canonical variates \eqn{a_1^*},..., \eqn{a_J^*}.\cr
   \verb{    }(c) Record t* = sum_(j,k) c_jk g(Cov(X_j^*a_j^*, X_k^*a_k^*).

(2) Sparse CCA is run on the blocks \eqn{X_1},..., \eqn{X_J} to obtain
    canonical variates \eqn{a_1},..., \eqn{a_J}.

(3) Record t = sum_(j,k) c_jk g(Cov(X_ja_j, X_ka_k).

(4) The resulting p-value is given by $mean(t* > t)$; that is, the fraction
of t* that exceed the value of t obtained from the real data.

Then, choose the tuning parameter values that gives the smallest value in
Step 4.

This function only selects tuning parameters for the first deflation stage
of S/RGCCA. By default, this function performs a one-dimensional
search in tuning parameter space.
}
\examples{
####################################
# Permutation based strategy for   #
# determining the best shrinkage   #
# parameters (par_type = "tau")    #
####################################

data(Russett)
blocks <- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = Russett[, 6:11]
)

C <- matrix(c(
  0, 0, 1,
  0, 0, 1,
  1, 1, 0
), 3, 3)

# default value: 10 vectors from rep(0, length(blocks))
# to rep(1, length(blocks)), uniformly distributed.

fit <- rgcca_permutation(blocks,
  connection = C,
  par_type = "tau",
  par_length = 10, n_perms = 2,
  n_cores = 1
)

print(fit)
plot(fit)
fit$bestpenalties
\dontrun{
# It is possible to define explicitly K combinations of shrinkage
# parameters to be tested and in that case a matrix of dimension KxJ is
# required. Each row of this matrix corresponds to one specific set of
# shrinkage parameters.
par_value <- matrix(c(
  0, 0, 0,
  1, 1, 0,
  0.5, 0.5, 0.5,
  sapply(blocks, RGCCA:::tau.estimate),
  1, 1, 1
), 5, 3, byrow = TRUE)


perm.out <- rgcca_permutation(blocks,
  connection = C,
  par_type = "tau",
  par_value = par_value,
  n_perms = 5, n_cores = 1
)

print(perm.out)
plot(perm.out)

# with superblock

perm.out <- rgcca_permutation(blocks,
  par_type = "tau",
  superblock = TRUE,
  scale = TRUE, scale_block = FALSE,
  n_perms = 5, n_cores = 1
)

print(perm.out)
plot(perm.out)

# used a fitted rgcca_permutation object as input of the rgcca function
fit.rgcca <- rgcca(perm.out)
fit.rgcca$call$tau
fit.rgcca$call$scale
fit.rgcca$call$scale_block

######################################
# Permutation based strategy for     #
# determining the best sparsity      #
# parameters (par_type = "sparsity") #
######################################

# defaut value: 10 vectors from minimum values
# (1/sqrt(ncol(X1)), ..., 1/sqrt(ncol(XJ))
# to rep(1, J), uniformly distributed.

perm.out <- rgcca_permutation(blocks,
  par_type = "sparsity",
  n_perms = 50, n_cores = 1
)

print(perm.out)
plot(perm.out)
perm.out$bestpenalties

# when par_value is a vector of length J. Each element of the vector
# indicates the maximum value of sparsity to be considered for each block.
# par_length (default value = 10) vectors from minimum values
# (1/sqrt(ncol(X1)), ..., 1/sqrt(ncol(XJ)) to maximum values, uniformly
# distributed, are then considered.

perm.out <- rgcca_permutation(blocks,
  connection = C,
  par_type = "sparsity",
  par_value = c(0.6, 0.75, 0.5),
  par_length = 7, n_perms = 20,
  n_cores = 1, tol = 1e-3
)

print(perm.out)
plot(perm.out)
perm.out$bestpenalties

# when par_value is a scalar, the same maximum value is applied
# for each block

perm.outt <- rgcca_permutation(blocks,
  connection = C,
  par_type = "sparsity",
  par_value = 0.8, par_length = 5,
  n_perms = 10, n_cores = 1
)

perm.out$penalties

######################################
# speed up the permutation procedure #
######################################

# The rgcca_permutation function can be quite time-consuming. Since
# approximate estimates of the block weight vectors are acceptable in this
# case, it is possible to reduce the value of the tolerance (tol argument)
# of the RGCCA algorithm to speed up the permutation procedure.
#
require(gliomaData)
data(ge_cgh_locIGR)
A <- ge_cgh_locIGR$multiblocks
Loc <- factor(ge_cgh_locIGR$y)
levels(Loc) <- colnames(ge_cgh_locIGR$multiblocks$y)
A[[3]] <- A[[3]][, -3]
C <- matrix(c(0, 0, 1, 0, 0, 1, 1, 1, 0), 3, 3)

# check dimensions of the blocks
sapply(A, dim)

par_value <- matrix(c(
  seq(0.1, 1, by = 0.1),
  seq(0.1, 1, by = 0.1),
  rep(0, 10)
), 10, 3, byrow = FALSE)

fit <- rgcca_permutation(A,
  connection = C,
  par_type = "tau",
  par_value = par_value,
  par_length = 10,
  n_perms = 10, n_cores = 1, tol = 1e-2
)
print(fit)
plot(fit)
}

}
\references{
Witten, D. M., Tibshirani, R., & Hastie, T. (2009). A penalized
matrix decomposition, with applications to sparse principal components and
canonical correlation analysis. Biostatistics, 10(3), 515-534.
}
