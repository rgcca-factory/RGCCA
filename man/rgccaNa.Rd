% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgccaNa.R
\name{rgccaNa}
\alias{rgccaNa}
\title{Regularized Generalized Canonical Correlation Analysis (RGCCA)}
\usage{
rgccaNa(
  blocks,
  method,
  connection = 1 - diag(length(blocks)),
  tau = rep(1, length(blocks)),
  ncomp = rep(1, length(blocks)),
  scheme = "centroid",
  scale = TRUE,
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  verbose = TRUE,
  scale_block = TRUE,
  prescaling = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{blocks}{A list that contains the J blocks of variables X1, X2, ..., XJ. 
Block Xj is a matrix of dimension n x p_j where p_j is the number of 
variables in X_j.}

\item{method}{Either a character corresponding to the used method 
("complete","knn","em","sem") or a function taking a list of J blocks (A) as 
only parameter and returning the imputed list. 
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete 
subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data 
(NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms 
with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest 
Neighbor. 1 can be replace by another number (such as knn3) to impute with 
the 3-Nearest Neighbors.}}}

\item{connection}{A symmetric matrix (J*J) that describes the relationships 
between blocks. Elements of the connection matrix must be positive ; but 
usually equal to 1 if block \eqn{j} and block \eqn{k} are connected, and 0 
otherwise.}

\item{tau}{Either a 1*J vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix 
containing the values of the regularization parameters (default: tau = 1, 
for each block and each dimension). Tau varies from 0 (maximizing the 
correlation) to 1 (maximizing the covariance). If tau = "optimal" the 
regularization paramaters are estimated for each block and each dimension 
using the Schafer and Strimmer (2005) analytical formula . If tau is a 
\eqn{1\times J} vector, tau[j] is identical across the dimensions of block 
\eqn{\mathbf{X}_j}. If tau is a matrix, tau[k, j] is associated with 
\eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j}). It can 
be estimated by using \link{rgcca_permutation}.}

\item{ncomp}{A vector of length J indicating the number of block components 
for each block.}

\item{scheme}{A character string or a function giving the scheme function for 
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). The scheme function 
 can be any continously differentiable convex functin and it is possible to 
 design explicitely the sheme function (e.g. function(x) x^4) as argument of 
 rgcca function.  See (Tenenhaus et al, 2017) for details.}

\item{scale}{A logical value indicating if each block is standardized}

\item{init}{A character giving the mode of initialization to use in the 
algorithm. The alternatives are either by Singular Value Decompostion ("svd") 
or random ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised 
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for the convergence of the algorithm.}

\item{verbose}{A logical value indicating if the progress of the 
algorithm is reported while computing.}

\item{scale_block}{A logical value indicating if each block is divided by 
the square root of its number of variables.}

\item{prescaling}{A logical value indicating if the scaling has been done
outside of the function.}

\item{quiet}{A logical value indicating if the warning messages are reported.}
}
\value{
\item{Y}{A list of \eqn{J} elements. Each element of \eqn{Y} is a 
matrix that contains the analysis components for the corresponding block.}

\item{a}{A list of \eqn{J} elements. Each element of \eqn{a} is a 
matrix that contains the outer weight vectors for each block.}

\item{astar}{A list of \eqn{J} elements. Each element of astar is a 
matrix defined as Y[[j]][, h] = A[[j]]\%*\%astar[[j]][, h].}

\item{C}{A symmetric matrix (J*J) that describes the relationships 
between blocks}

\item{tau}{Either a 1*J vector or a \eqn{\mathrm{max}(ncomp) \times J} 
matrix containing the values of the regularization parameters (default: 
tau = 1, for each block and each dimension). Tau varies from 0 (maximizing 
the correlation) to 1 (maximizing the covariance). If tau = "optimal" the 
regularization paramaters are estimated for each block and each dimension 
using the Schafer and Strimmer (2005) analytical formula . If tau is a 
\eqn{1\times J} vector, tau[j] is identical across the dimensions of block 
\eqn{\mathbf{X}_j}. If tau is a matrix, tau[k, j] is associated with 
\eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j}). It can 
be estimated by using \link{rgcca_permutation}.}

\item{ncomp}{A vector of 1*J integers giving the number of component 
for each blocks}

\item{crit}{A vector that contains for each component the 
values of the objective function across iterations.}

\item{mode}{A vector of length J that contains the formulation 
("primal" or "dual") applied to each of the \eqn{J} blocks within the RGCCA 
alogrithm}

\item{AVE}{A list of numeric values that reports indicators of model 
quality based on the Average Variance Explained (AVE): AVE(for each block), 
AVE(outer model), AVE(inner model).}
}
\description{
imputeRGCCA allows to choose the imputation method before running RGCCA
}
\examples{
data(Russett)
X_agric = as.matrix(Russett[, c("gini", "farm", "rent")])
X_ind = as.matrix(Russett[,c("gnpr", "labo")])
X_polit = as.matrix(Russett[ , c("demostab", "dictator")])
X_agric[c(2,4),] = NA
X_ind[1, ]= NA
X_polit[5, 1]= NA
A = list(Agric = X_agric, Ind = X_ind, Polit = X_polit)
rgccaNa(A, method="nipals")
}
\references{
Tenenhaus A. and Tenenhaus M., (2011), Regularized Generalized 
Canonical Correlation Analysis, Psychometrika, Vol. 76, Nr 2, pp 257-284.

Tenenhaus A., Philippe C. and Frouin, V. (2015). Kernel 
generalized canonical correlation analysis. Computational Statistics and 
Data Analysis, 90, 114-131.

Schafer J. and Strimmer K., (2005), A shrinkage approach to 
large-scale covariance matrix estimation and implications for functional 
genomics. Statistical Applications in Genetics and Molecular Biology 4:32.
}
