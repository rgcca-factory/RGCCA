% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgcca_permutation.R
\name{rgcca_permutation}
\alias{rgcca_permutation}
\title{Tune the S/RGCCA hyper-parameters by permutation.}
\usage{
rgcca_permutation(
  blocks,
  par_type,
  par_value = NULL,
  par_length = 10,
  n_perms = 20,
  n_cores = parallel::detectCores() - 1,
  quiet = TRUE,
  scale = TRUE,
  scale_block = TRUE,
  type = NULL,
  connection = 1 - diag(length(blocks)),
  scheme = "factorial",
  ncomp = rep(1, length(blocks)),
  tau = rep(1, length(blocks)),
  sparsity = rep(1, length(blocks)),
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  response = NULL,
  superblock = FALSE,
  method = "nipals",
  rgcca_res = NULL,
  parallelization = NULL
)
}
\arguments{
\item{blocks}{A list that contains the J blocks of variables X1, X2, ..., XJ. 
Block Xj is a matrix of dimension n x p_j where p_j is the number of 
variables in X_j.}

\item{par_type}{A character string indicating the parameter to tune between 
"sparsity" and "tau"}

\item{par_value}{It could be either (i) A matrix of dimension IxJ (where 
J the number of blocks and I the number of combinations to be tested), or 
(ii) a vector of length J length ) or 
a numeric value giving sets of penalties (tau for RGCCA, sparsity for SGCCA) 
to be tested, one row by combination. By default, it takes 10 sets between 
min values (0 for RGCCA and 1/sqrt(ncol(Xj)) for SGCCA) and 1.}

\item{par_length}{An integer indicating the number of sets of parameters to 
be tested (if par_value = NULL). The parameters are uniformly distributed.}

\item{n_perms}{Number of permutations for each set of constraints
(default is 20).}

\item{n_cores}{Number of cores for parallelization}

\item{quiet}{A logical value indicating if the warning messages are reported.}

\item{scale}{A logical value indicating if each block is standardized}

\item{scale_block}{A logical value indicating if each block is divided by 
the square root of its number of variables.}

\item{type}{A character string indicating the multi-block component
method to consider: rgcca, sgcca, pca, spca, pls, spls, cca, 
ifa, ra, gcca, maxvar, maxvar-b, maxvar-a, mcoa,cpca-1, cpca-2, 
cpca-4, hpca, maxbet-b, maxbet, maxdiff-b, maxdiff, maxvar-a,  
sabscor, ssqcor, ssqcor, ssqcov-1, ssqcov-2, ssqcov, sumcor, 
sumcov-1, sumcov-2, sumcov, sabscov, sabscov-1, sabscov-2.}

\item{connection}{A symmetric matrix (J*J) that describes the relationships 
between blocks. Elements of the connection matrix must be positive ; but 
usually equal to 1 if block \eqn{j} and block \eqn{k} are connected, and 0 
otherwise.}

\item{scheme}{A character string or a function giving the scheme function for 
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). The scheme function 
 can be any continously differentiable convex functin and it is possible to 
 design explicitely the sheme function (e.g. function(x) x^4) as argument of 
 rgcca function.  See (Tenenhaus et al, 2017) for details.}

\item{ncomp}{A vector of length J indicating the number of block components 
for each block.}

\item{tau}{Either a 1*J vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix 
containing the values of the regularization parameters (default: tau = 1, 
for each block and each dimension). Tau varies from 0 (maximizing the 
correlation) to 1 (maximizing the covariance). If tau = "optimal" the 
regularization paramaters are estimated for each block and each dimension 
using the Schafer and Strimmer (2005) analytical formula . If tau is a 
\eqn{1\times J} vector, tau[j] is identical across the dimensions of block 
\eqn{\mathbf{X}_j}. If tau is a matrix, tau[k, j] is associated with 
\eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j}). It can 
be estimated by using \link{rgcca_permutation}.}

\item{sparsity}{Either a \eqn{1*J} vector or a \eqn{max(ncomp) * J} matrix 
encoding the L1 constraints applied to the outer weight vectors. The amount 
of sparsity varies between \eqn{1/sqrt(p_j)} and 1 (larger values of sparsity 
correspond to less penalization). If sparsity is a vector, L1-penalties are 
the same for all the weights corresponding to the same block but different 
components: 
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.
If sparsity is a matrix, each row \eqn{h} defines the constraints applied to 
the weights corresponding to components \eqn{h}:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[h,j] \sqrt{p_j}.} It can be 
estimated by using \link{rgcca_permutation}.}

\item{init}{A character giving the mode of initialization to use in the 
algorithm. The alternatives are either by Singular Value Decompostion ("svd") 
or random ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised 
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for the convergence of the algorithm.}

\item{response}{Position of the response block}

\item{superblock}{Boolean indicating the presence of the superblock. 
Default = TRUE}

\item{method}{Either a character corresponding to the used method 
("complete","knn","em","sem") or a function taking a list of J blocks (A) as 
only parameter and returning the imputed list. 
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete 
subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data 
(NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms 
with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest 
Neighbor. 1 can be replace by another number (such as knn3) to impute with 
the 3-Nearest Neighbors.}}}

\item{rgcca_res}{A fitted RGCCA object (see  \code{\link[RGCCA]{rgcca}})}

\item{parallelization}{if TRUE, the bootstrap is processed in parallel. If 
parallelization = NULL (default), parallelization is always performed except 
for Windows if length(n_boot) < 10.}
}
\value{
\item{zstat}{The vector of Z-statistics, one per set of tuning 
parameters}

\item{bestpenalties}{The set of tuning parameters that gives the 
highest Z-statistics}

\item{permcrit}{Matrix of permuted S/RGCCA criteria. The ith row of 
permcrit contains the n_perms values of the permuted S/RGCCA criteria 
obtained for each set of tuning parameters.}

\item{means}{A vector that contains, for each set of tuning 
parameters, the mean of the permuted R/SGCCA criteria}

\item{sds}{A vector that contains, for each set of tuning 
parameters, the standard deviation of the permuted R/SGCCA criteria}

\item{crit}{A vector that contains, for each set of tuning 
parameters, the value of the R/SGCCA criteria obtained from the original 
blocks}

\item{pval}{The vector of p-values, one per set of tuning parameters}

\item{penalties}{A matrix giving, the set of tuning paramaters 
considered during the permutation procedure (tau or sparsity).}
}
\description{
This function can be used to automatically select the hyper-parameters 
(amount of sparsity for sgcca or shrinkage parameters for RGCCA)
A permutation based strategy very similar to the one proposed in 
(Witten et al, 2009) is proposed.
}
\details{
The tuning parameters are selected using the permutation scheme proposed in 
(Witten et al, 2009). For each candidate tuning parameter value, the 
following is performed: 

(1) Repeat the following n_perms times (for n_perms large): \cr
   \verb{    }(a) The samples in \eqn{X_1},..., \eqn{X_J} are randomly 
   permuted blocks: \eqn{X_1^*},..., \eqn{X_J^*}. \cr
   \verb{    }(b) S/RGCCA is run on the permuted data sets \eqn{X_1^*},..., 
      \eqn{X_J^*} to get canonical variates \eqn{a_1^*},..., \eqn{a_J^*}.\cr
   \verb{    }(c) Record t* = sum_(j,k) c_jk g(Cov(X_j^*a_j^*, X_k^*a_k^*). 
      
(2) Sparse CCA is run on the blocks \eqn{X_1},..., \eqn{X_J} to obtain 
    canonical variates \eqn{a_1},..., \eqn{a_J}. 

(3) Record t = sum_(j,k) c_jk g(Cov(X_ja_j, X_ka_k). 

(4) The resulting p-value is given by $mean(t* > t)$; that is, the fraction 
of t* that exceed the value of t obtained from the real data. 

Then, choose the tuning parameter value that gives the smallest value in 
Step 4.

This function only selects tuning parameters for the first deflation stage 
of S/RGCCA. By default, this function performs a one-dimensional 
search in tuning parameter space.
}
\examples{
####################################
# Permutation based strategy for   #
# determining the best shrinkage   # 
# parameters (par_type = "tau")    #
####################################

data("Russett")
blocks = list(agriculture = Russett[, seq(3)], 
              industry = Russett[, 4:5], 
              politic = Russett[, 6:11] )
              
C <-  matrix(c(0, 0, 1, 
               0, 0, 1, 
               1, 1, 0), 3, 3)

# default value: 10 vectors from rep(0, length(blocks))
# to rep(1, length(blocks)), uniformly distributed.
fit = rgcca_permutation(blocks, connection = C,
                        par_type = "tau", 
                        n_perms = 5, n_cores = 1)
                        
print(fit)
plot(fit)
fit$bestpenalties

# It is possible to define explicitly K combinations of shrinkage
# parameters to be tested and in that case a matrix of dimension KxJ is 
# required. Each row of this matrix corresponds to one specific set of 
# shrinkage parameters. 
par_value = matrix(c(0, 0, 0, 
                      1, 1, 0,
                      0.5, 0.5, 0.5,
                      sapply(blocks, RGCCA:::tau.estimate), 
                      1, 1, 1), 5, 3, byrow = TRUE)

                                                                 
fit <- rgcca_permutation(blocks, connection = C,
                         par_type = "tau", 
                         par_value = par_value, 
                         n_perms = 5, n_cores = 1)

print(fit)
plot(fit)

# with superblock

fit.permute <- rgcca_permutation(blocks, par_type = "tau", 
                                 superblock = TRUE,
                                 scale = TRUE, scale_block = FALSE,
                                 n_perms = 5, n_cores = 1)

print(fit.permute)
plot(fit.permute)

fit.rgcca <- rgcca(fit.permute)
fit.rgcca$call$tau
fit.rgcca$call$scale
fit.rgcca$call$scale_block

######################################
# Permutation based strategy for     #
# determining the best sparsity      # 
# parameters (par_type = "sparsity") #
######################################

# defaut value: 10 vectors from minimum values 
# (1/sqrt(ncol(X1)), ..., 1/sqrt(ncol(XJ)) 
# to rep(1, J), uniformly distributed.

fit <- rgcca_permutation(blocks, par_type = "sparsity", 
                         n_perms = 5, n_cores = 1)
                         
print(fit)
plot(fit)
fit$bestpenalties  

# when par_value is a vector of length J. Each element of the vector 
# indicates the maximum value of sparsity to be considered for each block.
# par_length (default value = 10) vectors from minimum values 
# (1/sqrt(ncol(X1)), ..., 1/sqrt(ncol(XJ)) to maximum values, uniformly 
# distributed, are then considered. 

fit <- rgcca_permutation(blocks, connection = C, 
                         par_type = "sparsity", 
                         par_value = c(0.6, 0.75, 0.5), 
                         par_length = 7, n_perms = 20, 
                         n_cores = 1, tol = 1e-3)
                         
	print(fit)
	plot(fit)
	fit$bestpenalties
	
# when par_value is a scalar, the same maximum value is applied 
# for each block

fit <- rgcca_permutation(blocks, connection = C, 
                         par_type = "sparsity", 
                         par_value = 0.8, par_length = 5, 
                         n_perms = 10, n_cores = 1)
   
fit$penalties    

######################################
# speed up the permutation procedure #
######################################

# The rgcca_permutation function can be quite time-consuming. Since an 
# approximate estimate of the block weight vectors is acceptable in this 
# case, it is possible to reduce the value of the tolerance (tol argument) 
# of the RGCCA algorithm to speed up this permutation procedure.
# 
# require(gliomaData)
# data(ge_cgh_locIGR)
# A <- ge_cgh_locIGR$multiblocks
# Loc <- factor(ge_cgh_locIGR$y)
# levels(Loc) <- colnames(ge_cgh_locIGR$multiblocks$y)
# A[[3]] = A[[3]][, -3]
# C <-  matrix(c(0, 0, 1, 0, 0, 1, 1, 1, 0), 3, 3)
#
# check dimensions of the blocks
# sapply(A, dim)
#
# par_value = matrix(c(seq(0.1, 1, by = 0.1),
#                      seq(0.1, 1, by = 0.1),
#                      rep(0, 10)), 10, 3, byrow = FALSE)
#                       
# system.time(fit <- rgcca_permutation(A, connection = C, 
#                          par_type = "tau", 
#                          par_value = par_value,
#                          par_length = 10,
#                          n_perms = 10, n_cores = 1, tol = 1e-2)
#                          )
# print(fit)
# plot(fit)

}
\references{
Witten, D. M., Tibshirani, R., & Hastie, T. (2009). A penalized 
matrix decomposition, with applications to sparse principal components and 
canonical correlation analysis. Biostatistics, 10(3), 515-534.
}
