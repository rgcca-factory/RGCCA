% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sgcca.R
\name{sgcca}
\alias{sgcca}
\title{Variable Selection For Generalized Canonical Correlation Analysis
(SGCCA)}
\usage{
sgcca(
  blocks,
  connection = 1 - diag(length(blocks)),
  sparsity = rep(1, length(blocks)),
  ncomp = rep(1, length(blocks)),
  scheme = "centroid",
  init = "svd",
  bias = TRUE,
  tol = .Machine$double.eps,
  verbose = FALSE,
  quiet = FALSE,
  na.rm = TRUE,
  superblock = FALSE,
  response = NULL,
  n_iter_max = 1000
)
}
\arguments{
\item{blocks}{A list that contains the J blocks of variables
\eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}{X1, X2, ..., XJ}.
Block \eqn{\mathbf{X}_j}{Xj} is a matrix of dimension
\eqn{n \times p_j}{n x p_j} where n is the number of
observations and \eqn{p_j} the number of variables.}

\item{connection}{A symmetric matrix (\eqn{J \times J}{J x J}) that
describes the relationships between blocks.}

\item{sparsity}{Either a \eqn{1*J} vector or a \eqn{max(ncomp) * J} matrix
encoding the L1 constraints applied to the outer weight vectors. The amount
of sparsity varies between \eqn{1/sqrt(p_j)} and 1 (larger values of sparsity
correspond to less penalization). If sparsity is a vector, L1-penalties are
the same for all the weights corresponding to the same block but different
components:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.
If sparsity is a matrix, each row \eqn{h} defines the constraints applied to
the weights corresponding to components \eqn{h}:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[h,j] \sqrt{p_j}.} It can be
estimated by using \link{rgcca_permutation}.}

\item{ncomp}{Vector of length J indicating the number of block components
for each block.}

\item{scheme}{Character string or a function giving the scheme function for
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). The scheme function
 can be any continously differentiable convex function and it is possible to
 design explicitely the scheme function (e.g. function(x) x^4) as argument of
 rgcca function.  See (Tenenhaus et al, 2017) for details.}

\item{init}{Character string giving the type of initialization to use in
the  algorithm. It could be either by Singular Value Decompostion ("svd")
or by random initialisation ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for the convergence of the algorithm.}

\item{verbose}{Logical value indicating if the progress of the
algorithm is reported while computing.}

\item{quiet}{Logical value indicating if warning messages are reported.}

\item{na.rm}{If TRUE, runs sgcca only on available data.}

\item{superblock}{Boolean indicating the presence of a superblock
(deflation strategy must be adapted when a superblock is used).}

\item{response}{Numerical value giving the position of the response block.
When the response argument is filled the supervised mode is automatically
activated.}

\item{n_iter_max}{Integer giving the algorithm's maximum number of
iterations.}
}
\value{
\item{Y}{A list of \eqn{J} elements. Each element of \eqn{Y} is a
matrix that contains the analysis components for the corresponding block.}

\item{a}{A list of \eqn{J} elements. Each element of \eqn{a} is a
matrix that contains the outer weight vectors for each block.}

\item{astar}{A list of \eqn{J} elements. Each column of astar[[j]] is
a vector such that Y[[j]][, h] = blocks[[j]] \%*\% astar[[j]][, h].}

\item{crit}{A vector of integer that contains for each component the
values of the analysis criteria across iterations.}

\item{AVE}{A list of numerical values giving the indicators of model
quality based on the Average Variance Explained (AVE): AVE(for each block),
AVE(outer model), AVE(inner model).}
}
\description{
SGCCA extends RGCCA to address the issue of variable selection. Specifically,
RGCCA is combined with an L1-penalty that gives rise to Sparse GCCA (SGCCA)
which is implemented in the function sgcca().
Given \eqn{J} matrices \eqn{X_1, X_2, ..., X_J}, that represent
\eqn{J} sets of variables observed on the same set of \eqn{n} individuals.
The matrices \eqn{X_1, X_2, ..., X_J} must have the same number of rows, but
may (and usually will) have different numbers of columns. Blocks are not
necessarily fully connected within the SGCCA framework. Hence the use of
SGCCA requires the construction (user specified) of a design matrix
(\eqn{connection}) that characterizes the connections between blocks.
Elements of the symmetric design matrix \eqn{connection = (c_{jk})} are
equal to 1 if block \eqn{j} and block \eqn{k} are connected, and 0 otherwise.
The SGCCA algorithm is very similar to the RGCCA algorithm and keeps the same
monotone convergence properties (i.e. the bounded criteria to be maximized
increases at each step of the iterative procedure and hits at convergence
a stationary point).
Moreover, using a deflation strategy, sgcca() enables the computation of
several SGCCA block components (specified by ncomp) for each block. Block
components for each block are guaranteed to be orthogonal when using this
deflation strategy. The so-called symmetric deflation is considered in this
implementation, i.e. each block is deflated with respect to its own
component. Moreover, we stress that the numbers of components per block
could differ from one block to another.
}
\examples{
#############
# Example 1 #
#############
\dontrun{
# Download the dataset's package at http://biodev.cea.fr/sgcca/.
# --> gliomaData_0.4.tar.gz

require(gliomaData)
data(ge_cgh_locIGR)

blocks <- ge_cgh_locIGR$multiblocks
Loc <- factor(ge_cgh_locIGR$y)
levels(Loc) <- colnames(ge_cgh_locIGR$multiblocks$y)
connection <- matrix(c(0, 0, 1, 0, 0, 1, 1, 1, 0), 3, 3)
tau <- c(1, 1, 0)

# rgcca algorithm using the dual formulation for X1 and X2
# and the dual formulation for X3
blocks[[3]] <- blocks[[3]][, -3]
result.rgcca <- rgcca(
  blocks = blocks, connection = connection, tau = tau,
  ncomp = c(2, 2, 1), scheme = "factorial",
  verbose = TRUE, method = "rgcca"
)
# sgcca algorithm
result.sgcca <- rgcca(
  blocks = blocks, connection = connection,
  sparsity = c(.071, .2, 1), ncomp = c(2, 2, 1),
  scheme = "centroid", verbose = TRUE, method = "sgcca"
)

############################
# plot(y1, y2) for (RGCCA) #
############################
layout(t(1:2))
plot(result.rgcca$Y[[1]][, 1], result.rgcca$Y[[2]][, 1],
  col = "white", xlab = "Y1 (GE)", ylab = "Y2 (CGH)",
  main = "Factorial plan of RGCCA"
)
text(result.rgcca$Y[[1]][, 1], result.rgcca$Y[[2]][, 1],
  Loc,
  col = as.numeric(Loc), cex = .6
)
plot(result.rgcca$Y[[1]][, 1], result.rgcca$Y[[1]][, 2],
  col = "white", xlab = "Y1 (GE)",
  ylab = "Y2 (GE)", main = "Factorial plan of RGCCA"
)
text(result.rgcca$Y[[1]][, 1], result.rgcca$Y[[1]][, 2],
  Loc,
  col = as.numeric(Loc), cex = .6
)

############################
# plot(y1, y2) for (SGCCA) #
############################
layout(t(1:2))
plot(result.sgcca$Y[[1]][, 1], result.sgcca$Y[[2]][, 1],
  col = "white", xlab = "Y1 (GE)",
  ylab = "Y2 (CGH)", main = "Factorial plan of SGCCA"
)
text(result.sgcca$Y[[1]][, 1], result.sgcca$Y[[2]][, 1],
  Loc,
  col = as.numeric(Loc), cex = .6
)

plot(result.sgcca$Y[[1]][, 1], result.sgcca$Y[[1]][, 2],
  col = "white", xlab = "Y1 (GE)",
  ylab = "Y2 (GE)", main = "Factorial plan of SGCCA"
)
text(result.sgcca$Y[[1]][, 1], result.sgcca$Y[[1]][, 2],
  Loc,
  col = as.numeric(Loc), cex = .6
)

# sgcca algorithm with multiple components and different
# L1 penalties for each components
# (-> sparsity is a matrix)
init <- "random"
result.sgcca <- sgcca(blocks, connection,
  sparsity = matrix(c(.071, .2, 1, 0.06, 0.15, 1),
    nrow = 2, byrow = TRUE
  ),
  ncomp = c(2, 2, 1), scheme = "factorial", bias = TRUE,
  init = init, verbose = TRUE
)
# number of non zero elements per dimension
apply(result.sgcca$a[[1]], 2, function(x) sum(x != 0))
# (-> 145 non zero elements for a11 and 107 non zero elements for a12)
apply(result.sgcca$a[[2]], 2, function(x) sum(x != 0))
# (-> 85 non zero elements for a21 and 52 non zero elements for a22)
init <- "svd"
result.sgcca <- sgcca(blocks, connection,
  sparsity = matrix(c(.071, .2, 1, 0.06, 0.15, 1),
    nrow = 2, byrow = TRUE
  ),
  ncomp = c(2, 2, 1), scheme = "factorial",
  bias = TRUE,
  init = init, verbose = TRUE
)
}
}
\references{
Tenenhaus, A., Philippe, C., Guillemot, V., Le Cao, K. A.,
Grill, J., and Frouin, V. , "Variable selection for generalized canonical
correlation analysis.," Biostatistics, vol. 15, no. 3, pp. 569-583, 2014.
}
